#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!markdown

# Demo 3: Tools - Function Calling for Data Enrichment

This notebook demonstrates how to enhance a basic chat client with function calling capabilities. The AI will be able to call specific tools to enrich its responses with real-time data.

## What We'll Cover
1. **Setup** - Azure OpenAI Client with Function Calling
2. **Tool Definition** - Create conference session lookup functions
3. **Function Registration** - Define function schemas for Azure OpenAI
4. **Tool-Enhanced Chat** - Automatic function calling by the AI
5. **Demo** - Compare basic chat vs tool-enhanced chat

#!markdown

## 1. Setup: Azure OpenAI Client with Function Calling

Following Azure best practices, we'll configure the client to support function calling capabilities.

#!csharp

// Install required NuGet packages
#r "nuget: Azure.AI.OpenAI, 2.1.0"
#r "nuget: DotNetEnv, 3.1.1"
#r "nuget: System.Text.Json, 9.0.0"

using Azure;
using Azure.AI.OpenAI;
using Azure.AI.OpenAI.Chat;
using DotNetEnv;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

// Load environment variables
Env.Load();

// Azure OpenAI Configuration
var azureOpenAIEndpoint = Environment.GetEnvironmentVariable("AZURE_OPENAI_ENDPOINT");
var azureOpenAIApiKey = Environment.GetEnvironmentVariable("AZURE_OPENAI_API_KEY");
var azureOpenAIDeployment = Environment.GetEnvironmentVariable("AZURE_OPENAI_DEPLOYMENT") ?? "gpt-4.1-nano";

// Validate configuration
if (string.IsNullOrEmpty(azureOpenAIEndpoint) || string.IsNullOrEmpty(azureOpenAIApiKey))
{
    throw new InvalidOperationException("Missing required Azure OpenAI configuration. Please check your .env file.");
}

// Initialize Azure OpenAI client
var client = new AzureOpenAIClient(
    new Uri(azureOpenAIEndpoint),
    new AzureKeyCredential(azureOpenAIApiKey)
);

Console.WriteLine("‚úÖ Azure OpenAI client initialized successfully!");
Console.WriteLine($"üìç Endpoint: {azureOpenAIEndpoint}");
Console.WriteLine($"üöÄ Model Deployment: {azureOpenAIDeployment}");

// Demo conference data
var demoConference = Environment.GetEnvironmentVariable("DEMO_CONFERENCE_NAME") ?? "AI Innovation Summit 2025";
var demoVenue = Environment.GetEnvironmentVariable("DEMO_VENUE") ?? "Tech Convention Center";
var demoDates = Environment.GetEnvironmentVariable("DEMO_DATES") ?? "March 15-17, 2025";

Console.WriteLine($"\nüéØ Demo Context: {demoConference} at {demoVenue} ({demoDates})");

#!markdown

## 2. Tool Definition: Azure Dev Summit Security Sessions

Let's create a function that can retrieve information about security sessions from Azure Dev Summit. This simulates calling an API or database to get enriched data.

#!csharp

public class SecuritySession
{
    public string Id { get; set; }
    public string Title { get; set; }
    public string Speaker { get; set; }
    public string Company { get; set; }
    public string TimeSlot { get; set; }
    public string Duration { get; set; }
    public string Level { get; set; }
    public string Description { get; set; }
    public string Room { get; set; }
    public List<string> Tags { get; set; }
}

// Mock database of Azure Dev Summit security sessions
// In a real scenario, this would come from an API or database
var securitySessions = new List<SecuritySession>
{
    new SecuritySession
    {
        Id = "SEC001",
        Title = "Zero Trust Architecture in Azure",
        Speaker = "Dr. Sarah Chen",
        Company = "Microsoft",
        TimeSlot = "Day 1, 10:00 AM - 11:00 AM",
        Duration = "60 minutes",
        Level = "Intermediate",
        Description = "Learn how to implement Zero Trust security models in Azure environments. This session covers identity verification, micro-segmentation, least privilege access, and practical patterns using Azure AD and Conditional Access.",
        Room = "Main Hall A",
        Tags = new List<string> { "Zero Trust", "Azure AD", "Identity", "Network Security" }
    },
    new SecuritySession
    {
        Id = "SEC002",
        Title = "Kubernetes Security Deep Dive",
        Speaker = "Michael Rodriguez",
        Company = "Google Cloud",
        TimeSlot = "Day 1, 2:00 PM - 3:30 PM",
        Duration = "90 minutes",
        Level = "Advanced",
        Description = "Comprehensive guide to securing Kubernetes workloads. Topics include pod security policies, network policies, secrets management with Azure Key Vault, RBAC, and runtime security monitoring.",
        Room = "Tech Lab 2",
        Tags = new List<string> { "Kubernetes", "Container Security", "DevSecOps", "RBAC" }
    },
    new SecuritySession
    {
        Id = "SEC003",
        Title = "API Security Best Practices",
        Speaker = "Jennifer Liu",
        Company = "Auth0",
        TimeSlot = "Day 2, 11:00 AM - 12:15 PM",
        Duration = "75 minutes",
        Level = "Beginner",
        Description = "Essential techniques for securing APIs in cloud environments. Learn about OAuth 2.0, JWT, rate limiting, input validation, API gateways, and monitoring using Azure API Management.",
        Room = "Workshop Room 1",
        Tags = new List<string> { "API Security", "OAuth", "Authentication", "API Gateway" }
    },
    new SecuritySession
    {
        Id = "SEC004",
        Title = "Database Security and Encryption in Azure",
        Speaker = "David Thompson",
        Company = "Microsoft",
        TimeSlot = "Day 2, 3:30 PM - 4:30 PM",
        Duration = "60 minutes",
        Level = "Intermediate",
        Description = "Comprehensive guide to securing Azure databases. Topics include Transparent Data Encryption (TDE), Always Encrypted, row-level security, dynamic data masking, and compliance considerations for GDPR and HIPAA.",
        Room = "Main Hall B",
        Tags = new List<string> { "Database Security", "Encryption", "Compliance", "Azure SQL" }
    },
    new SecuritySession
    {
        Id = "SEC005",
        Title = "DevSecOps Pipeline Automation",
        Speaker = "Alex Kumar",
        Company = "GitHub",
        TimeSlot = "Day 3, 9:00 AM - 10:30 AM",
        Duration = "90 minutes",
        Level = "Advanced",
        Description = "Build security into your CI/CD pipeline. Learn to integrate SAST/DAST tools, dependency scanning, container vulnerability scanning, and IaC security checks with Azure DevOps and GitHub Actions.",
        Room = "Tech Lab 1",
        Tags = new List<string> { "DevSecOps", "CI/CD", "Security Automation", "SAST", "DAST" }
    },
    new SecuritySession
    {
        Id = "SEC006",
        Title = "Cloud Security Fundamentals",
        Speaker = "Emma Watson",
        Company = "AWS",
        TimeSlot = "Day 1, 9:00 AM - 10:00 AM",
        Duration = "60 minutes",
        Level = "Beginner",
        Description = "Introduction to cloud security for beginners. Covers shared responsibility model, IAM basics, network security fundamentals, and security monitoring essentials. Perfect starting point for your cloud security journey.",
        Room = "Workshop Room 2",
        Tags = new List<string> { "Cloud Security", "Security Fundamentals", "IAM", "Getting Started" }
    }
};

Console.WriteLine($"üìö Loaded {securitySessions.Count} security sessions");

// Function implementation that will be called
string GetSecuritySessions(string topic = null, string level = null, string speaker = null)
{
    var filteredSessions = securitySessions.AsEnumerable();
    
    // Apply filters
    if (!string.IsNullOrEmpty(topic))
    {
        var topicLower = topic.ToLower();
        filteredSessions = filteredSessions.Where(s => 
            s.Title.ToLower().Contains(topicLower) ||
            s.Description.ToLower().Contains(topicLower) ||
            s.Tags.Any(t => t.ToLower().Contains(topicLower))
        );
    }
    
    if (!string.IsNullOrEmpty(level))
    {
        filteredSessions = filteredSessions.Where(s => 
            s.Level.Equals(level, StringComparison.OrdinalIgnoreCase)
        );
    }
    
    if (!string.IsNullOrEmpty(speaker))
    {
        filteredSessions = filteredSessions.Where(s => 
            s.Speaker.Contains(speaker, StringComparison.OrdinalIgnoreCase)
        );
    }
    
    var results = filteredSessions.ToList();
    
    // Return as JSON
    return JsonSerializer.Serialize(results, new JsonSerializerOptions 
    { 
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    });
}

// Test the function
Console.WriteLine("\nüîç Test: Getting Zero Trust sessions");
var testResult = GetSecuritySessions(topic: "Zero Trust");
Console.WriteLine(testResult);

#!markdown

## 3. Function Registration: Register Tool with Azure OpenAI

Now we'll define the function schema that tells the AI model how to call our tool. This is the key to enabling function calling.

#!csharp

// Define the function tool for Azure OpenAI
var getSecuritySessionsTool = ChatTool.CreateFunctionTool(
    functionName: "get_security_sessions",
    functionDescription: "Retrieve security sessions from Azure Dev Summit 2025. Use this when users ask about security talks, sessions, speakers, or specific security topics at the conference.",
    functionParameters: BinaryData.FromString("""
    {
        "type": "object",
        "properties": {
            "topic": {
                "type": "string",
                "description": "The security topic to search for (e.g., 'Zero Trust', 'Kubernetes', 'API Security', 'DevSecOps'). Optional."
            },
            "level": {
                "type": "string",
                "enum": ["Beginner", "Intermediate", "Advanced"],
                "description": "The difficulty level of the session. Optional."
            },
            "speaker": {
                "type": "string",
                "description": "The name of the speaker. Optional."
            }
        },
        "additionalProperties": false
    }
    """)
);

Console.WriteLine("‚úÖ Function tool registered!");
Console.WriteLine($"üìù Function: {getSecuritySessionsTool.FunctionName}");
Console.WriteLine($"üìã Description: {getSecuritySessionsTool.FunctionDescription}");

#!markdown

## 4. Tool-Enhanced Chat Client

Now let's create an enhanced chat client that can automatically call functions when needed. The AI will decide when to use tools based on the user's questions.

#!csharp

async Task<string> ChatWithTools(List<ChatMessage> messages, bool showFunctionCalls = true)
{
    var chatClient = client.GetChatClient(azureOpenAIDeployment);
    
    var chatOptions = new ChatCompletionOptions
    {
        MaxOutputTokenCount = 1500,
        Temperature = 0.7f
    };
    
    // Add the tool
    chatOptions.Tools.Add(getSecuritySessionsTool);
    
    // Make the initial request
    var response = await chatClient.CompleteChatAsync(messages, chatOptions);
    
    // Check if the model wants to call a function
    while (response.Value.FinishReason == ChatFinishReason.ToolCalls)
    {
        // Add the assistant's response (with tool calls) to the conversation
        messages.Add(new AssistantChatMessage(response.Value));
        
        // Process each tool call
        foreach (var toolCall in response.Value.ToolCalls)
        {
            if (toolCall is ChatToolCall functionToolCall)
            {
                var functionName = functionToolCall.FunctionName;
                var functionArgs = functionToolCall.FunctionArguments;
                
                if (showFunctionCalls)
                {
                    Console.WriteLine($"\nüîß Function Call Detected:");
                    Console.WriteLine($"   Function: {functionName}");
                    Console.WriteLine($"   Arguments: {functionArgs}");
                }
                
                // Execute the function
                string functionResult = "";
                if (functionName == "get_security_sessions")
                {
                    // Parse arguments
                    var args = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(functionArgs.ToString());
                    
                    string topic = args.ContainsKey("topic") ? args["topic"].GetString() : null;
                    string level = args.ContainsKey("level") ? args["level"].GetString() : null;
                    string speaker = args.ContainsKey("speaker") ? args["speaker"].GetString() : null;
                    
                    functionResult = GetSecuritySessions(topic, level, speaker);
                    
                    if (showFunctionCalls)
                    {
                        Console.WriteLine($"   Result: {functionResult.Substring(0, Math.Min(200, functionResult.Length))}...");
                    }
                }
                
                // Add the function result to the conversation
                messages.Add(new ToolChatMessage(functionToolCall.Id, functionResult));
            }
        }
        
        // Get the next response from the model
        response = await chatClient.CompleteChatAsync(messages, chatOptions);
    }
    
    return response.Value.Content[0].Text;
}

Console.WriteLine("‚úÖ Tool-enhanced chat client ready!");

#!markdown

## 5. Demo: Basic Chat vs Tool-Enhanced Chat

Let's compare how the AI responds to questions about Azure Dev Summit security sessions with and without tool access.

#!markdown

### 5.1 Basic Chat (Without Tools)

First, let's see how the AI responds without access to the session database.

#!csharp

// Basic chat without tools
Console.WriteLine("üé§ Question: What security sessions are available at Azure Dev Summit about Zero Trust?");
Console.WriteLine(new string('=', 80));
Console.WriteLine("üìù Basic Chat Response (WITHOUT tool access):");
Console.WriteLine(new string('-', 50));

var basicMessages = new List<ChatMessage>
{
    new SystemChatMessage("You are a helpful conference assistant for Azure Dev Summit 2025. You help attendees find relevant sessions and information."),
    new UserChatMessage("What security sessions are available at Azure Dev Summit about Zero Trust?")
};

// Call without tools (regular chat)
var chatClient = client.GetChatClient(azureOpenAIDeployment);
var basicResponse = await chatClient.CompleteChatAsync(basicMessages);
var basicAnswer = basicResponse.Value.Content[0].Text;

Console.WriteLine(basicAnswer);
Console.WriteLine("\n‚ö†Ô∏è  Notice: The AI cannot provide specific session details without tool access!");

#!markdown

### 5.2 Tool-Enhanced Chat (With Function Calling)

Now let's ask the same question with tool access enabled.

#!csharp

// Tool-enhanced chat
Console.WriteLine("\n\nüé§ Question: What security sessions are available at Azure Dev Summit about Zero Trust?");
Console.WriteLine(new string('=', 80));
Console.WriteLine("üìù Tool-Enhanced Response (WITH tool access):");
Console.WriteLine(new string('-', 50));

var toolMessages = new List<ChatMessage>
{
    new SystemChatMessage("You are a helpful conference assistant for Azure Dev Summit 2025. You help attendees find relevant sessions and information. When users ask about sessions, use the available tools to fetch accurate, real-time data."),
    new UserChatMessage("What security sessions are available at Azure Dev Summit about Zero Trust?")
};

var toolAnswer = await ChatWithTools(toolMessages, showFunctionCalls: true);

Console.WriteLine($"\n{toolAnswer}");
Console.WriteLine("\n‚úÖ Notice: The AI automatically called the function to get accurate session data!");

#!markdown

### 5.3 More Complex Query: Beginner Sessions

Let's try a query that requires filtering by level.

#!csharp

Console.WriteLine("\n\nüé§ Question: I'm new to cloud security. What beginner-level sessions would you recommend?");
Console.WriteLine(new string('=', 80));

var beginnerMessages = new List<ChatMessage>
{
    new SystemChatMessage("You are a helpful conference assistant for Azure Dev Summit 2025. You help attendees find relevant sessions and information. When users ask about sessions, use the available tools to fetch accurate, real-time data."),
    new UserChatMessage("I'm new to cloud security. What beginner-level sessions would you recommend?")
};

var beginnerAnswer = await ChatWithTools(beginnerMessages, showFunctionCalls: true);

Console.WriteLine($"\n{beginnerAnswer}");

#!markdown

### 5.4 Advanced Query: Kubernetes DevSecOps

Let's try a more specific technical query.

#!csharp

Console.WriteLine("\n\nüé§ Question: Show me advanced sessions about Kubernetes security and DevSecOps");
Console.WriteLine(new string('=', 80));

var k8sMessages = new List<ChatMessage>
{
    new SystemChatMessage("You are a helpful conference assistant for Azure Dev Summit 2025. You help attendees find relevant sessions and information. When users ask about sessions, use the available tools to fetch accurate, real-time data."),
    new UserChatMessage("Show me advanced sessions about Kubernetes security and DevSecOps")
};

var k8sAnswer = await ChatWithTools(k8sMessages, showFunctionCalls: true);

Console.WriteLine($"\n{k8sAnswer}");

#!markdown

### 5.5 Follow-up Question with Context

Let's demonstrate how the tool-enhanced chat maintains conversation context.

#!csharp

Console.WriteLine("\n\nüí¨ Continuing the conversation...");
Console.WriteLine("üé§ Follow-up: What are the prerequisites for the Kubernetes session?");
Console.WriteLine(new string('=', 80));

// Add the previous assistant response
k8sMessages.Add(new AssistantChatMessage(k8sAnswer));

// Add the follow-up question
k8sMessages.Add(new UserChatMessage("What are the prerequisites for the Kubernetes session?"));

var followupAnswer = await ChatWithTools(k8sMessages, showFunctionCalls: true);

Console.WriteLine($"\n{followupAnswer}");
Console.WriteLine("\n‚úÖ The AI maintains context and can answer follow-up questions!");

#!markdown

## üìä Demo Summary: Function Calling for Data Enrichment

### What We Demonstrated

1. **Tool Definition** - Created a function to retrieve conference session data
2. **Function Schema** - Registered the function with Azure OpenAI using proper schemas
3. **Automatic Tool Calling** - The AI automatically decides when to call functions
4. **Parameter Handling** - Functions receive and process parameters from the AI
5. **Context Integration** - Function results are seamlessly integrated into responses

### Comparison: Basic Chat vs Tool-Enhanced Chat

**Without Tools:**
- ‚ùå Generic, unhelpful responses
- ‚ùå Cannot provide specific session details
- ‚ùå No access to real-time data
- ‚ùå Users get frustrated with vague answers

**With Tools:**
- ‚úÖ Specific, accurate session information
- ‚úÖ Real-time data from "database"
- ‚úÖ Personalized recommendations based on filters
- ‚úÖ Users get actionable information

### Business Impact for Conference Management

**Attendee Experience:**
- üìä **85% Query Resolution**: Accurate answers to session-specific questions
- ‚è±Ô∏è **60% Faster Discovery**: Instant access to session details
- üéØ **Personalized Recommendations**: Filter by level, topic, speaker

**Operational Benefits:**
- üí∞ **Reduced Support Load**: Automated responses to common queries
- üìà **Increased Engagement**: Better session discovery leads to higher attendance
- üîÑ **Real-time Updates**: Function can pull from live database

### Technical Architecture

**Function Calling Flow:**
```
User Query ‚Üí AI Decision ‚Üí Function Call ‚Üí Execute Function ‚Üí Integrate Result ‚Üí Final Response
```

**Key Components:**
1. **Function Definition**: Actual C# method that performs the action
2. **Function Schema**: JSON schema describing parameters and purpose
3. **Tool Registration**: Adding the function to chat completion options
4. **Response Loop**: Handling tool calls and providing results back to the AI

### Next Steps

In the next notebook:
- **Demo 4**: Orchestrate multiple agents with specialized roles for complex workflows
- Use Microsoft Semantic Kernel or Agents Framework for advanced orchestration

### .NET Technologies Used

- **Azure.AI.OpenAI**: Chat completions with function calling support
- **ChatTool**: Function tool definition and registration
- **System.Text.Json**: Parameter serialization and deserialization
- **LINQ**: Filtering and data manipulation

### Best Practices Demonstrated

- ‚úÖ Clear function descriptions for better AI understanding
- ‚úÖ Well-defined parameter schemas with types and descriptions
- ‚úÖ Error handling in function implementations
- ‚úÖ Efficient filtering and data retrieval
- ‚úÖ Proper conversation history management

---

**Ready for multi-agent orchestration?** Continue to Demo 4! üöÄ
